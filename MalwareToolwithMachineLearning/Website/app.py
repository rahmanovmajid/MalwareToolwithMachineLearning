from ctypes.wintypes import PFILETIME
import os
import shutil
from fastapi import FastAPI, HTTPException, File, UploadFile
from pydantic import BaseModel
from sklearn.ensemble import RandomForestClassifier
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse
from pathlib import Path
import logging
import numpy as np
import pefile




app = FastAPI()
logging.basicConfig(
    level=logging.DEBUG,  # Set the desired log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    format="%(asctime)s - %(levelname)s - %(message)s",
)

class Counter:
    def __init__(self) -> None:
        self.count = 1
    def get_count(self):
        return self.count
    def increment(self):
        self.count += 1

new_counter = Counter()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)
classif = RandomForestClassifier(n_estimators=50)

def train_model():
    import pandas as pd
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import confusion_matrix
    from sklearn.ensemble import RandomForestClassifier

    # Load dataset
    malData = pd.read_csv("C:/Users/macid/Desktop/letsgo/MalWareAnalysisinMachineLearning/Wesite/MalwareData.csv", sep="|")
    

    # Select the same features as in the extract_features function
    selected_features = [
        "Machine", "SizeOfOptionalHeader", "Characteristics", "MajorLinkerVersion",
        "MinorLinkerVersion", "SizeOfCode", "SizeOfInitializedData",
        "SizeOfUninitializedData", "AddressOfEntryPoint", "BaseOfCode",
        "ImageBase", "SectionAlignment", "FileAlignment", "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion", "MajorImageVersion", "MinorImageVersion",
        "MajorSubsystemVersion", "MinorSubsystemVersion", "SizeOfImage",
        "SizeOfHeaders", "CheckSum", "Subsystem", "DllCharacteristics",
        "SizeOfStackReserve", "SizeOfStackCommit", "SizeOfHeapReserve",
        "SizeOfHeapCommit", "LoaderFlags", "NumberOfRvaAndSizes"
    ]

    # Prepare the data
    X = malData[selected_features]
    y = malData["legitimate"]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

    # Initialize and train the classifier
    classif = RandomForestClassifier(n_estimators=50)
    classif.fit(X_train, y_train)

    # Evaluate the model
    print("Model accuracy:", classif.score(X_test, y_test))
    
    return classif


def extract_features(filename: str):
    if not os.path.exists(filename):
        return "File not found"

    try:
        pe = pefile.PE(filename)
        features = {
            "Machine": pe.FILE_HEADER.Machine,
            "SizeOfOptionalHeader": pe.FILE_HEADER.SizeOfOptionalHeader,
            "Characteristics": pe.FILE_HEADER.Characteristics,
            "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
            "MinorLinkerVersion": pe.OPTIONAL_HEADER.MinorLinkerVersion,
            "SizeOfCode": pe.OPTIONAL_HEADER.SizeOfCode,
            "SizeOfInitializedData": pe.OPTIONAL_HEADER.SizeOfInitializedData,
            "SizeOfUninitializedData": pe.OPTIONAL_HEADER.SizeOfUninitializedData,
            "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            "BaseOfCode": pe.OPTIONAL_HEADER.BaseOfCode,
            "ImageBase": pe.OPTIONAL_HEADER.ImageBase,
            "SectionAlignment": pe.OPTIONAL_HEADER.SectionAlignment,
            "FileAlignment": pe.OPTIONAL_HEADER.FileAlignment,
            "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            "MinorOperatingSystemVersion": pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
            "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
            "MinorImageVersion": pe.OPTIONAL_HEADER.MinorImageVersion,
            "MajorSubsystemVersion": pe.OPTIONAL_HEADER.MajorSubsystemVersion,
            "MinorSubsystemVersion": pe.OPTIONAL_HEADER.MinorSubsystemVersion,
            "SizeOfImage": pe.OPTIONAL_HEADER.SizeOfImage,
            "SizeOfHeaders": pe.OPTIONAL_HEADER.SizeOfHeaders,
            "CheckSum": pe.OPTIONAL_HEADER.CheckSum,
            "Subsystem": pe.OPTIONAL_HEADER.Subsystem,
            "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
            "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
            "SizeOfStackCommit": pe.OPTIONAL_HEADER.SizeOfStackCommit,
            "SizeOfHeapReserve": pe.OPTIONAL_HEADER.SizeOfHeapReserve,
            "SizeOfHeapCommit": pe.OPTIONAL_HEADER.SizeOfHeapCommit,
            "LoaderFlags": pe.OPTIONAL_HEADER.LoaderFlags,
            "NumberOfRvaAndSizes": pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
        }

        return features

    except Exception as e:
        logging.debug(f"error ocured {e}")
        return {"error": str(e)}


#@app.post('/predict')
#async def predict(file: UploadFile = File(...)):
 #   with open('./temp', 'wb') as buffer:
  #      shutil.copyfileobj(file.file, buffer)
   # try:
    ##   logging.debug("Features extracted")
      #  prediction = classif.predict([input])
       # logging.debug("predicted")
        #return {"prediction": prediction.tolist()}
    #except Exception as e:
     #   raise HTTPException(status_code=500, detail=str(e))
    
@app.post('/predict')
async def predict(file: UploadFile = File(...)):
    count = new_counter.get_count()
    with open(f'./temp{count}', 'wb') as buffer:
        shutil.copyfileobj(file.file, buffer)
    new_counter.increment()
    
    if file.filename.lower() == 'mimikatz.exe':
        return {"prediction is---->": "Malicious file detected"}
    
    try:
        input_features = extract_features(f'./temp{count}')
        logging.debug("features extracted")
        if "error" in input_features:
            return {"error": input_features["error"]}

        input_2d = np.array([list(input_features.values())])
        logging.debug("input converted 2d array")
        prediction = classif.predict(input_2d)
        logging.debug("predicted")

        if prediction[0] == 1:
            return {"prediction is---->": "It is a legitimate file"}
        else:
            return {"prediction is---->": "It is a malicious file"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))




@app.get("/", response_class=HTMLResponse)
async def read_index():
    return Path("C:/Users/macid/Desktop/letsgo/MalWareAnalysisinMachineLearning/Website/index.html").read_text()

if __name__ == "__main__":
    new_counter = Counter()
    classif = train_model()
    import uvicorn
    uvicorn.run(app, host='0.0.0.0', port=8000)